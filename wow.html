//not done - snake game

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Document</title>
</head>
<body>
<div id = 'grid'></div>
</body>
<script>

//X IS THE UP/DOWN Y IS THE LEFT RIGHT grid[x][y]
//GRID IS UPDATED AND USED AS A TEMPLATE TO WORK OFF... 
let grid = [
  [0,0,0,0,0,0,0,0,0,0], 
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0]
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0]
]; 

//USED SO THE SNAKE CAN CONTINUE UPDATING BEFORE MAKING A TURN
let wait_until_snake_is_done_updating_to_add_a_turn = 'waiting';

//EVERY SNAKE IS A NODE WITH AN X,Y AND DIRECTION
let snake = [{ 
  x: 0, 
  y: 0, 
  direction: 's', 
  type_: 'leading_node', 
  turns: []
}];  

//PLACE APPLES, CREATE ELEMENTS WITH ID'S AS GRID I-J
function setup_grid() {

  for(let i = 0; i < grid.length; i++) { 
    for(let j = 0; j < grid[i].length; j++) { 
      let r = Math.floor(Math.random() * 5)
      if(r === 4) { 
        grid[i][j] = 2;
      }
    }
  }

  grid[snake[0].x][snake[0].y] = 1;

  let div_element = `<div style = "border-radius: 50%">`;
  for(let i = 0; i < grid.length; i++) { 
    for(let j = 0; j < grid[i].length; j++) { 
      let color;
      if(grid[i][j] === 1) { //1 is coming from the snake
        color = 'red';
      } else if(grid[i][j] === 2) { 
        color = 'purple'
      } else { 
        color = 'black';
      }                 
      //X/I(UP-DOWN)    
      //Y/J(LEFT-RIGHT)
      div_element += `<span id = '${i}-${j}' style = 'border-color: 1px solid ${color}; float: left; height: 20px; width: 20px; display: in-line-block; background-color: ${color}'> </span>`; //not that good at css
    }
    div_element += `<br>`; 

  }
  div_element += '</div>';

  document.getElementById('grid').innerHTML = div_element;

}

//ADD A TURN TO EVERY NODE. THE TURN STARTS WHERE THE HEAD NODE IS. DON'T INTERRUPT UPDATING SNAKE.
document.addEventListener('keydown', (event) => {
  if(event.key ===  37) { 
    go_east();
  } else if(event.key ===  39) { 
    go_west();
  } else if(event.key ===  38) { 
    go_north();
  } else if(event.key ===  40) { 
    go_south();
  } else { 
    return;
  }
});

function go_south() { 
  if(snake[0].direction === 's' || snake[0].direction === 'n') return;
  //DONT INTERRUP UPDATING SNAKE
  if(wait_until_snake_is_done_updating_to_add_a_turn === 'waiting') return go_south();
  for(let i = 0; i < snakes.length; i++) { 
    snake[i].turns.push({ 
      turn_at_x_coordinate: snake[0].x, 
      turn_at_y_coordinate: snake[0].y, 
      direction_for_node_to_turn_in: 's'
    })
  } 
} 

function go_north() { 
  if(snake[0].direction === 's' || snake[0].direction === 'n') return;
  if(wait_until_snake_is_done_updating_to_add_a_turn === 'waiting') return go_north();
  for(let i = 0; i < snakes.length; i++) { 
    snake[i].turns.push({ 
      turn_at_x_coordinate: snake[0].x, 
      turn_at_y_coordinate: snake[0].y, 
      direction_for_node_to_turn_in: 'n'
    })
  }
} 

function go_west() { 
  if(snake[0].direction === 'w' || snake[0].direction === 'e') return;
  if(wait_until_snake_is_done_updating_to_add_a_turn === 'waiting') return go_west();
  for(let i = 0; i < snakes.length; i++) { 
    snake[i].turns.push({ 
      turn_at_x_coordinate: snake[0].x, 
      turn_at_y_coordinate: snake[0].y, 
      direction_for_node_to_turn_in: 'w'
    })
  }
} 

function go_east() { 
  if(snake[0].direction === 'e' || snake[0].direction === 'w') return;
  if(wait_until_snake_is_done_updating_to_add_a_turn === 'waiting') return go_east();
  for(let i = 0; i < snakes.length; i++) { 
    snake[i].turns.push({
      turn_at_x_coordinate: snake[0].x, 
      turn_at_y_coordinate: snake[0].y, 
      direction_for_node_to_turn_in: 'e'
    })
  } 
} 

function move_snake() { 

  //USE THIS TO PREVENT THE NEXT TURN FROM BEING EXECUTED
  wait_until_snake_is_done_updating_to_add_a_turn = 'waiting'; 
  let added_snake_after_eating_apple = null;

  let DOCUMENT_UPDATE_NEW_BLACK_X_Y_ARRAY = [];
  let DOCUMENT_UPDATE_NEW_RED_X_Y_ARRAY = [];

  for(let i = 0; i < snake.length; i++) {

    //TURNING NODE WHEN LANDING ON TURN POINT
    if(
      typeof snake[i].turns[0] !== 'undefined' && 
      snake[i].x === snake[i].turns[0].turn_at_x_coordinate && 
      snake[i].y === snake[i].turns[0].turn_at_y_coordinate 
    ) { 
      snake[i].direction = snake[i].turns[0].direction_for_node_to_turn_in;
      snake[i].turns.unshift(); 
    }

    //HEAD NODE FOUND AN APPLE - APPEND TO END
    if(i === 0 && grid[snake[i].x][snake[i].y] === 2) { 
      let last_node = snake[snake.length - 1];
      added_snake_after_eating_apple = { 
        x: last_node.direction === 'n' ? last_node.x += 1 : last_node.direction === 's' ? last_node.x -= 1 : last_node.x, 
        y: last_node.direction === 'e' ? last_node.y -= 1 : last_node.direction === 'w' ? last_node.y += 1 : last_node.y, 
        direction: last_node.direction, 
        type_: 'trailing_node', 
        turns: last_node.turns
      };
    }

    //JUST FOR ERROR HANDLING
    grid[snake[i].x][snake[i].y] = 0;

    //defragment object black new x,y - OPTION 1 FOR DISPLAY
    // DOCUMENT_UPDATE_NEW_BLACK_X_Y_ARRAY.push({
    //  x: snake[i].x, 
    //  y: snake[i].y
    // });

    //REGULAR TURN SNAKE COLOR BLACK REALLY QUICK, ON THE NEXT ITERATION, WILL BE UPDATED - OPTION 2 DISPLAY
    document.querySelector(`#${snake[i].x}-${snake[i].y}`).backgroundColor = 'black'; //ADD CSS FADE IN AFFECT

    //FADE IN AFFECT - OPTION 3 DISPLAY 
    // snake[i].direction === 'n' ? fade_in_north(snake[i].x, snake[i].y, 'red-to-black-fade') : snake[i].direction === 's' ? fade_in_south(snake[i].x, snake[i].y, 'red-to-black-fade') : 
    // snake[i].direction === 'e' ?  fade_in_east(snake[i].x, snake[i].y, 'red-to-black-fade') : snake[i].direction === 'w' ? fade_in_west(snake[i].x, snake[i].y, 'red-to-black-fade') : error_main('bad input request : CSS_FADE');

    //MOVE SNAKE NODE
    if(snake[i].direction === 'n') {
      snake[i].x -= 1;
    } else if(snake[i].direction === 's') { 
      snake[i].x += 1;
    } else if(snake[i].direction === 'e') { 
      snake[i].y += 1;
    } else if(snake[i].direction === 'w') { 
      snake[i].y -= 1;
    }

    //SNAKE HEAD MOVED OUT OF BOUNDS
    if(i === 0 && typeof grid[snake[i].x][snake[i].y] === 'undefined') { 
     error_main('the snake is off the grid. can not execute above two steps : USER ERROR');
     return;
    }

    //TEMPLATING
    grid[snake[i].x][snake[i].y] = 1;

    //OPTION 1 FOR LEAST COPMUTED RESPONSE - DISPLAY
    // DOCUMENT_UPDATE_NEW_RED_X_Y_ARRAY.push({
    //  x: snake[i].x, 
    //  y: snake[i].y
    // });

    //REGULAR TURN SNAKE COLOR BLACK REALLY QUICK, ON THE NEXT ITERATION, WILL BE UPDATED - OPTION 2 DISPLAY - medium COMPUTED
    document.querySelector(`#${snake[i].x}-${snake[i].y}`).backgroundColor = 'red';

    //FADE IN AFFECT - OPTION 3 DISPLAY -- MOST COMPUTED -- MAYBE JUST DO IT ON LAST
    // snake[i].direction === 'n' ? fade_in_north(snake[i].x, snake[i].y, 'black-to-red-fade') : snake[i].direction === 's' ? fade_in_south(snake[i].x, snake[i].y, 'black-to-red-fade') : 
    // snake[i].direction === 'e' ?  fade_in_east(snake[i].x, snake[i].y, 'black-to-red-fade') : snake[i].direction === 'w' ? fade_in_west(snake[i].x, snake[i].y, 'black-to-red-fade') : error_main('bad input request : CSS_FADE');

  }

  //OPTION FOR DISPLAY OPTION 1
  // for(let i = 0; i < DOCUMENT_UPDATE_NEW_BLACK_X_Y_ARRAY.length; i++) { 
  //   document.querySelector(`#${DOCUMENT_UPDATE_NEW_BLACK_X_Y_ARRAY[i].x}-${DOCUMENT_UPDATE_NEW_BLACK_X_Y_ARRAY[i].y}`).backgroundColor = 'red';
  // }
  // for(let i = 0; i < DOCUMENT_UPDATE_NEW_RED_X_Y_ARRAY.length; i++) { 
  //   document.querySelector(`#${DOCUMENT_UPDATE_NEW_RED_X_Y_ARRAY[i].x}-${DOCUMENT_UPDATE_NEW_RED_X_Y_ARRAY[i].y}`).backgroundColor = 'red';
  // }

  wait_until_snake_is_done_updating_to_add_a_turn = 'finished';

  if(added_snake_after_eating_apple !== null) {
    snakes.push(added_snake_after_eating_apple);
  }

  return setTimeout(function() { 
    return move_snake()
  }, 3000)

}

//PARSE AND RETRY ON : ERROR_MESSAGE
function error_main(error_message) { 
  throw new Error(error_message);
}

//FADE ANIMIMATIONS
// function fade_in_north(element_x, element_y, fade_type) {
//   if(fade_type === 'red_to_black_fade') { 
//    document.querySelector(`${element_x}-${element_y}`).backgroundColor = 'BLACK'; 
//   } 
//   if(fade_type === 'black_to_red_fade') { 
//    document.querySelector(`${element_x}-${element_y}`).backgroundColor = 'RED';
//   }
// }

// function fade_in_south(element_x, element_y, fade_type) { 
//   if(fade_type === 'red_to_black_fade') { 
//    document.querySelector(`${element_x}-${element_y}`).backgroundColor = 'BLACK';
//   } 
//   if(fade_type === 'black_to_red_fade') { 
//    document.querySelector(`${element_x}-${element_y}`).backgroundColor = 'RED';
//   }
// }

// function fade_in_east(element_x, element_y, fade_type) { 
//   if(fade_type === 'red_to_black_fade') { 
//    document.querySelector(`${element_x}-${element_y}`).backgroundColor = 'BLACK';
//   } 
//   if(fade_type === 'black_to_red_fade') { 
//    document.querySelector(`${element_x}-${element_y}`).backgroundColor = 'RED';
//   }
// }

// function fade_in_west(element_x, element_y, fade_type) { 
//   if(fade_type === 'red_to_black_fade') { 
//    document.querySelector(`${element_x}-${element_y}`).backgroundColor = 'BLACK';
//   } 
//   if(fade_type === 'black_to_red_fade') { 
//    document.querySelector(`${element_x}-${element_y}`).backgroundColor = 'RED';
//   }
// }

setup_grid();
//move_snake();

</script>
</html>
