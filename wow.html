<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Document</title>
</head>
<body
  INCOMPLETE
<div id = 'grid'></div>
</body>
<script>

//GRID IS UPDATED AND USED AS A TEMPLATE TO WORK OFF OF... 
let grid = [
  [0,0,0,0,0,0,0,0,0,0], 
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0]
]; 

//ITERITIVE ARRAY OF JAVASCRIPT SNAKE GRID SPACES USED TO DISPLAY STEPS. MAYBE IF NECESSARY
let grid_space = [];

//EVERY SNAKE IS A NODE WITH AN X,Y AND DIRECTION
let snake = [{ 
  x: 0, 
  y: 0, 
  direction: 's', 
  type_: 'leading_node', 
  turns: []
}]; 

//PLACE APPLES, CREATE ELEMENTS
function setup_grid() {

  for(let i = 0; i < grid.length; i++) { 
    for(let j = 0; j < grid[i].length; j++) { 
      let r = Math.floor(Math.random() * 5)
      if(r === 4) { 
        grid[i][j] = 2;
      }
    }
  }

  grid[snake[0].x][snake[0].y] = 1;

  let div_element = `<div style = "border-radius: 50%">`;
  for(let i = 0; i < grid.length; i++) { 
    for(let j = 0; j < grid[i].length; j++) { 
      let color;
      if(grid[i][j] === 1) { 
        color = 'red';
      } else if(grid[i][j] === 2) { 
        color = 'purple'
      } else { 
        color = 'black';
      }                 
      div_element += `<span id = '${i}-${j}' style = 'border-color: 1px solid ${color}; float: left; height: 20px; width: 20px; display: in-line-block; background-color: ${color}'> </span>`;
    }
    div_element += `<br>`; 

  }
  div_element += '</div>';

  document.getElementById('grid').innerHTML = div_element;

}

//ADD A TURN TO EVERY NODE. THE TURN STARTS WHERE THE HEAD NODE IS.
document.addEventListener('keydown', (event) => {
  alert(event.key);
  // if(event.key ===  'ArrowRight') { 
  //   go_east();
  // } else if(event.key ===  'ArrowWest') { 
  //   go_west();
  // } else if(event.key ===  'ArrowUp') { 
  //   go_north();
  // } else if(event.key === 'ArrowDown') { 
  //   go_south();
  // }
  move_snake();
});

function go_south() { 
  if(snake[0].direction === 's' || snake[0].direction === 'n') return;
  for(let i = 0; i < snake.length; i++) { 
    snake[i].turns.push({ 
      turn_at_x_coordinate: snake[0].x, 
      turn_at_y_coordinate: snake[0].y, 
      direction_for_node_to_turn_in: 's'
    })
  } 
} 

function go_north() { 
  if(snake[0].direction === 's' || snake[0].direction === 'n') return;
  for(let i = 0; i < snake.length; i++) { 
    snake[i].turns.push({ 
      turn_at_x_coordinate: snake[0].x, 
      turn_at_y_coordinate: snake[0].y, 
      direction_for_node_to_turn_in: 'n'
    })
  }
} 

function go_west() { 
  if(snake[0].direction === 'w' || snake[0].direction === 'e') return;
  for(let i = 0; i < snake.length; i++) { 
    snake[i].turns.push({ 
      turn_at_x_coordinate: snake[0].x, 
      turn_at_y_coordinate: snake[0].y, 
      direction_for_node_to_turn_in: 'w'
    })
  }
} 

function go_east() { 
  if(snake[0].direction === 'e' || snake[0].direction === 'w') return;
  for(let i = 0; i < snake.length; i++) { 
    snake[i].turns.push({
      turn_at_x_coordinate: snake[0].x, 
      turn_at_y_coordinate: snake[0].y, 
      direction_for_node_to_turn_in: 'e'
    })
  } 
} 

function move_snake() { 

  let add_snake_after_all_has_moved = false;

  for(let i = 0; i < snake.length; i++) {

    //TURNING NODE WHEN LANDING ON TURN POINT
    if(
      typeof snake[i].turns[0] !== 'undefined' && 
      snake[i].x === snake[i].turns[0].turn_at_x_coordinate && 
      snake[i].y === snake[i].turns[0].turn_at_y_coordinate 
    ) { 
      snake[i].direction = snake[i].turns[0].direction_for_node_to_turn_in;
      snake[i].turns.unshift(); 
    }

    //HEAD NODE FOUND AN APPLE - APPEND TO END
    if(i === 0 && grid[snake[i].x][snake[i].y] === 2) { 
      add_snake_after_all_has_moved = true;
    }

    //TEMPLATING
    grid[snake[i].x][snake[i].y] = 0;

    //THE LAST NODE IS ABOUT TO MOVE TO ITS NEXT LOCATION. TURN BLACK
    if(i === snake.length - 1) { 
      document.getElementById(`${snake[i].x}-${snake[i].y}`).style.backgroundColor = 'black';
    }

    //MOVE SNAKE NODE
    if(snake[i].direction === 'n') {
      snake[i].x -= 1;
    } else if(snake[i].direction === 's') { 
      snake[i].x += 1;
    } else if(snake[i].direction === 'e') { 
      snake[i].y += 1;
    } else if(snake[i].direction === 'w') { 
      snake[i].y -= 1;
    }

    //SNAKE HEAD MOVED OUT OF BOUNDS
    if(i === 0 && typeof grid[snake[i].x][snake[i].y] === 'undefined') { 
     return 'END GAME BECAUSE SNAKE RAN IS OF BOUNDS';
    }

    //TEMPLATING
    grid[snake[i].x][snake[i].y] = 1;

    //PUSHING ALL REDS ALONG
    document.getElementById(`${snake[i].x}-${snake[i].y}`).style.backgroundColor = 'red';

  }

  //ADDING A SNAKE NODE FOR THE NEXT ITERATION - 
  if(add_snake_after_all_has_moved === true) { 
    let last_node = snake[snake.length - 1];
    snake.push({ 
      x: last_node.direction === 'n' ? last_node.x += 1 : last_node.direction === 's' ? last_node.x -= 1 : last_node.x, 
      y: last_node.direction === 'e' ? last_node.y -= 1 : last_node.direction === 'w' ? last_node.y += 1 : last_node.y, 
      direction: last_node.direction, 
      type_: 'trailing_node', 
      turns: last_node.turns
    });
    if(typeof grid[last_node.x][last_node.y] === 'undefined') { 
      snake.pop(); //pop it... LOUDAAA
    }
  }

  //SNAKE RAN INTO ITSELF
  for(let i = snake.length - 1; i > 0; i--) { 
    if(snake[i].x === snake[0].x && snake[i].y === snake[0].y) { 
      return 'END GAME BECAUSE THE SNAKE RAN INTO ITSELF';
    }
  }

  //GRID WITH UPDATED 1's LOCATION
  grid_space.push(grid);

  // return setTimeout(function() { 
  //   return move_snake()
  // }, 250)

}

//PARSE AND RETRY ON : ERROR_MESSAGE
function error_main(error_message) { 
  throw new Error(error_message);
}

setup_grid();
//move_snake();

</script>
</html>
